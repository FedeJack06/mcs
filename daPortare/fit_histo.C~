///////////////////// ES ESAME 3 - SPETTROGRAMMA
{
  ifstream ifile("Dati_Spettrometro.dat");
  double tmp;
  TH1D *histo = new TH1D("histo", "", 70, 0.555, 0.595);
  while(ifile >> tmp){
    histo->Fill(tmp);
  }
  histo->Draw();
  /*
  TF1 *gaus = new TF1("gaus", "[0]*TMath::Gaus(x,[1],[2])");
  gaus->SetParameter(0, histo->GetEntries()*histo->GetBinWidth(1));
  gaus->SetParameter(1, histo->GetMean());
  gaus->SetParameter(2, histo->GetRMS());
  histo->Fit("gaus", "L");//uso likehood perch√® ho bin con freq < 5, no chi^2
  cout<<"p-value "<< gaus->GetProb() << endl;//valore < 0.05, rigetto gauss singola
  */
  TF1 *gaus2 = new TF1("gaus2", "[0]*([1]*TMath::Gaus(x,[2],[3]) +(1-[1])*TMath::Gaus(x, [4],[5]))");
  gaus2->SetParameter(0, histo->GetEntries()*histo->GetBinWidth(1));
  gaus2->SetParameter(2, 0.57);
  gaus2->SetParameter(3, 0.0001);
  gaus2->SetParameter(4, 0.582);
  gaus2->SetParameter(5, 0.0001);
  histo->Fit("gaus2", "L");
  cout<<"p-value "<< gaus2->GetProb() << endl;

  //calcolo A dalle due gaussiane
  double B=0.1, V=1e3; q=TMath::Qe();
  
  double d1 = gaus2->GetParameter(2);
  double m1 = (B*B*q/(2*V))*pow(d1/2, 2);
  double A1 = m1/1.66e-27;
  cout << "m1 :" << A1 << endl;

  double d2 = gaus2->GetParameter(4);
  double m2 = (B*B*q/(2*V))*pow(d2/2, 2);
  double A2 = m2/1.66e-27;
  cout << "m2 :" << A2 << endl;
}


///////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// HANDS ON FIT I - FIT LIN - GLS
namespace data{
  vector<double>  x, y, ex, ey;
}

double fun(const double *x,const double *par){
  return par[1]*(*x)+par[0];
}

void fcn(int &npar,double *gin,double &f,double *par,int iflag){
  f = 0.0;
  for (int i=0;i<data::x.size();i++){
    f += pow(data::y[i]-fun(&data::x[i],par),2)/(pow(data::ey[i],2) + pow(par[1]*data::ex[i],2));
    // Calcolo del Chi2
  }
}

void fitlin(){
  ifstream file("pendolo.dat");
  double x,y,ex,ey;
  while (file >> x >> y >> ex >> ey){
    data::x.push_back(x); data::y.push_back(y); data::ex.push_back(ex); data::ey.push_back(ey);
  }

  // Define the minimization problem
  TMinuit *minuit = new TMinuit(2); // numero di parametri  
  minuit->SetFCN(fcn);
  //minuit->SetErrorDef(1.0);
  minuit->DefineParameter(0,"beta_0",0,0.01,0.0,0.0);
  minuit->DefineParameter(1,"beta_1",4,0.01,0.0,0.0);
  // per ogni indice inserisco nome, valore iniziale, step, minimo, massimo del parametro

  // Minimize
  minuit->Command("MIGRAD"); // Comando di minimizzazione //HESSE calcolo preciso matrice di covarianza
  //MINOS calcolo erorrori asim
  //trova solo il minimo, e i parametri, non disegna
  double beta0, beta1, ebeta0, ebeta1;

  // Get result
  minuit->GetParameter(0,beta0,ebeta0);
  minuit->GetParameter(1,beta1,ebeta1);
  // per ogni indice estraggo il valore del parametro e del suo errore
  // minuit->GetParameter(indice,val,eval);

}

/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////
from iminuit import Minuit
from numpy   import *
import matplotlib.pyplot as plt

def f(x,par):
    return par[1]*x+par[0]

def chi2(par):
    val = 0
    for i in range(0,len(x)):
        val = val + ((y[i]-f(x[i],par))/ey[i])**2/(ey[i]**2 + (par[1]*ex[i])**2)
    return val

# Acquisizione dati
x,y,ex,ey = loadtxt('pendolo.dat',usecols=(0,1,2,3),unpack=True)

## Chiamo Minuit nella modalita' parametri passati tramite array
par = array([0, 4])
mn = Minuit(chi2,par)
mn.print_level = 4 #livello che mi da minuit sull'informazione
mn.migrad()
print("beta_0: %f +- %f "%(mn.values[0],mn.errors[0]))
print("beta_1: %f +- %f "%(mn.values[1],mn.errors[1]))
mn.draw_mnmatrix(cl=[1,2,3])
plt.show()

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////
from   iminuit import Minuit
from   numpy   import *
import matplotlib.pyplot as plt

def f(x,m,q):
    return m*x+q

def chi2(a,b): #m,q
    val = 0
    for i in range(0,len(x)):
        val = val + ((y[i]-f(x[i],a,b))/ey[i])**2
    return val

# Acquisizione dati
x,y,ex,ey = loadtxt('pendolo.dat',usecols=(0,1,2,3),unpack=True)
mn = Minuit(chi2, a=4, b=0)
mn.print_level = 3 #livello che mi da minuit sull'informazione
mn.migrad()
print("beta_0: %f +- %f "%(mn.values[0],mn.errors[0]))
print("beta_1: %f +- %f "%(mn.values[1],mn.errors[1]))
mn.draw_mnmatrix(cl=[1,2,3])
plt.show()

## Chiamo Minuit nella modalita' parametri passati tramite passaggio dei singoli parametri
## Esplorare la funzione draw_mnmatrix per fare i contour

///////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// SIMPLE FIT + CONTOUR
{
  TGraphErrors *gr = new TGraphErrors("pendolo.dat");
  TF1 *f = new TF1("f","[1]*x+[0]");
  f->SetParameter(0,4);
  f->SetParameter(1,0);
  gr->Draw("AP");
  // Correlation matrix
  auto ptr = gr->Fit("f","S");
  auto cov = ptr->GetCovarianceMatrix();
  cov.Print();
  auto cor = ptr->GetCorrelationMatrix();
  cor.Print();
  
  // Band
  gMinuit->SetErrorDef(1);
  auto grc = (TGraph*)gMinuit->Contour(10,0,1); //cast di tobject
  grc->Draw("AC");
  // Contour
}  
